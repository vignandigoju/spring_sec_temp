import React, { useState, useContext, useMemo, useEffect, useCallback } from 'react';
import ZoneRenderer from './ZoneRenderer';
import apiService from '../../api/apiService';
import { RequestContext } from '../../context/RequestContext';
import { PreferenceContext } from '../../context/PreferenceContext';
import { pollTask } from '../../utils/polling';
import { HistoryItem } from './HistoryItem';
import { AlertTriangle, X, ChevronLeft, ChevronRight } from 'lucide-react';
import JsonViewToggle from './JsonViewToggle';
import JsonHierarchicalView from './JsonHierarchicalView';
import ResultsTable from './ResultsTable';
import ConfirmDialog from './sharedComponents/ConfirmDialog';


const EndpointRenderer = ({ endpoint, serviceId, customUi = [] }) => {
  const [formData, setFormData] = useState({});
  const [localResponse, setLocalResponse] = useState(null);
  const [isLoading, setIsLoading] = useState(false);
  const [showConcurrencyWarning, setShowConcurrencyWarning] = useState(true);
  const [showConfirmDialog, setShowConfirmDialog] = useState(false);
  const [pendingExecution, setPendingExecution] = useState(false);


  const { history: contextHistory, updateRequest, fetchHistory: fetchGlobalHistory } = useContext(RequestContext);
  const { preferences, setJsonViewMode } = useContext(PreferenceContext);
  const { jsonViewMode } = preferences;


  const [localHistory, setLocalHistory] = useState([]);
  const [pagination, setPagination] = useState({ page: 1, per_page: 5, total: 0 });
  const [currentPage, setCurrentPage] = useState(1);
  const [isHistoryLoading, setIsHistoryLoading] = useState(true);
  const perPage = 5;


  // Check if this endpoint has a ConfirmDialog
  const confirmDialogConfig = useMemo(() => {
    return customUi.find(comp => 
      comp.name === 'ConfirmDialog' && 
      (!comp.layout?.zone || comp.layout.zone === 'body')
    );
  }, [customUi]);


  const fetchEndpointHistory = useCallback(async (page) => {
    setIsHistoryLoading(true);
    try {
      const filters = { application: serviceId, target_url: endpoint.path };
      const response = await apiService.getHistory({ ...filters, page, per_page: perPage });
      setLocalHistory(response.data.results || []);
      setPagination({
        page: response.data.page,
        per_page: response.data.per_page,
        total: response.data.total
      });
    } catch (error) {
      console.error(`Failed to fetch history for endpoint ${endpoint.path}:`, error);
      setLocalHistory([]);
    } finally {
      setIsHistoryLoading(false);
    }
  }, [serviceId, endpoint.path]);


  useEffect(() => {
    fetchEndpointHistory(currentPage);
  }, [currentPage, fetchEndpointHistory]);


  useEffect(() => {
    if (!contextHistory || contextHistory.length === 0) return;
    setLocalHistory(prevLocal => {
      const updatedItems = new Map(contextHistory.map(item => [item.task_id, item]));
      return prevLocal.map(localItem => updatedItems.get(localItem.task_id) || localItem);
    });
  }, [contextHistory]);


  const runningTasks = useMemo(() => {
    const combined = [...localHistory, ...contextHistory];
    const uniqueTasks = Array.from(new Map(combined.map(item => [item.task_id, item])).values());
    return uniqueTasks.filter(req =>
      req.application === serviceId &&
      req.target_url === endpoint.path &&
      ['PENDING', 'RUNNING'].includes(req.status)
    );
  }, [localHistory, contextHistory, serviceId, endpoint.path]);


  useEffect(() => {
    if (runningTasks.length === 0) {
      setShowConcurrencyWarning(true);
    }
  }, [runningTasks.length]);


  const hasCustomBodyComponents = useMemo(() => {
    return customUi.some(comp => {
      const zone = comp.layout?.zone || 'body';
      return zone === 'body';
    });
  }, [customUi]);


  const schemaProperties = useMemo(() => {
    const schema = endpoint.requestBody?.content?.['application/json']?.schema ||
                   endpoint.requestBody?.content?.['multipart/form-data']?.schema;
    
    if (!schema || !schema.properties) return [];


    const customFieldNames = customUi
      .filter(comp => comp.props?.name)
      .map(comp => comp.props.name);


    return Object.entries(schema.properties)
      .filter(([key]) => !customFieldNames.includes(key))
      .map(([key, propSchema]) => ({ key, propSchema }));
  }, [endpoint, customUi]);


  const extractParameters = useCallback(() => {
    const pathParams = {};
    const queryParams = {};
    
    if (endpoint.parameters) {
      endpoint.parameters.forEach(param => {
        const value = formData[param.name];
        if (value !== undefined && value !== '') {
          if (param.in === 'path') {
            pathParams[param.name] = value;
          } else if (param.in === 'query') {
            queryParams[param.name] = value;
          }
        }
      });
    }
    
    const pathParamMatches = endpoint.path.match(/\{([^}]+)\}/g);
    if (pathParamMatches) {
      pathParamMatches.forEach(match => {
        const paramName = match.replace(/[{}]/g, '');
        if (formData[paramName]) {
          pathParams[paramName] = formData[paramName];
        }
      });
    }
    
    return { pathParams, queryParams };
  }, [endpoint, formData]);


  const buildFinalPath = useCallback((pathParams) => {
    let finalPath = endpoint.path;
    
    Object.entries(pathParams).forEach(([key, value]) => {
      finalPath = finalPath.replace(`{${key}}`, value);
    });
    
    return finalPath;
  }, [endpoint.path]);


  const handleRun = async () => {
    setIsLoading(true);
    setLocalResponse(null);


    const { pathParams, queryParams } = extractParameters();
    const finalPath = buildFinalPath(pathParams);
    
    const isGet = endpoint.method === 'get';
    const isMultipart = !!endpoint.requestBody?.content?.['multipart/form-data'];
    
    let bodyData = { ...formData };
    Object.keys(pathParams).forEach(key => delete bodyData[key]);
    
    let requestConfig = {
      serviceId,
      method: endpoint.method,
      path: finalPath
    };


    if (isGet) {
      requestConfig.params = { ...queryParams, ...bodyData };
    } else if (isMultipart) {
      const formDataPayload = new FormData();
      Object.entries(bodyData).forEach(([key, value]) => {
        formDataPayload.append(key, value);
      });
      requestConfig.data = formDataPayload;
      requestConfig.headers = { 'Content-Type': 'multipart/form-data' };
    } else {
      if (Object.keys(bodyData).length > 0) {
        requestConfig.data = bodyData;
      }
    }


    try {
      const res = await apiService.executeOperation(requestConfig);
     
      const taskInfo = res.data?.response;


      if (res.status === 202 && taskInfo?.task_id && taskInfo?.task_endpoint) {
        window.showToast({
          type: 'info',
          title: 'Task Started',
          message: 'Your request is being processed...'
        });
        
        pollTask(
          taskInfo.task_endpoint,
          taskInfo.task_id,
          updateRequest,
          (finalResult) => {
            setLocalResponse({ type: 'success', data: finalResult });
            window.showToast({
              type: 'success',
              title: 'Task Completed',
              message: 'Operation finished successfully'
            });
          },
          (errorResult) => {
            setLocalResponse({ type: 'error', data: errorResult });
            window.showToast({
              type: 'error',
              title: 'Task Failed',
              message: errorResult?.error || 'Operation failed'
            });
          }
        );
      } else {
        setLocalResponse({ type: 'success', data: res.data });
        window.showToast({
          type: 'success',
          title: 'Success',
          message: 'Operation completed successfully'
        });
      }
    } catch (err) {
      const errorData = err.response?.data || err || { message: 'An unknown error occurred.' };
      setLocalResponse({ type: 'error', data: errorData });
      window.showToast({
        type: 'error',
        title: 'Error',
        message: errorData?.message || errorData?.error || 'Operation failed'
      });
    } finally {
      setIsLoading(false);
      setTimeout(() => {
        fetchEndpointHistory(1);
        fetchGlobalHistory();
      }, 500);
    }
  };


  const handleExecuteClick = () => {
    if (confirmDialogConfig) {
      setShowConfirmDialog(true);
      setPendingExecution(true);
    } else {
      handleRun();
    }
  };


  const handleConfirmExecute = () => {
    setShowConfirmDialog(false);
    setPendingExecution(false);
    handleRun();
  };


  const handleCancelExecute = () => {
    setShowConfirmDialog(false);
    setPendingExecution(false);
  };


  const renderSchemaInput = (key, propSchema) => {
    const commonClasses = "w-full p-2.5 border border-slate-300 rounded-md box-border font-inter focus:ring-2 focus:ring-accent focus:border-accent outline-none";
    const value = formData[key] || '';


    const handleChange = (e) => {
      if (propSchema.type === 'array') {
        setFormData(p => ({ ...p, [key]: e.target.value.split('\n').filter(Boolean) }));
      } else {
        setFormData(p => ({ ...p, [key]: e.target.value }));
      }
    };


    if (propSchema.format === 'binary') {
      return (
        <input 
          type="file" 
          onChange={(e) => setFormData(p => ({ ...p, [key]: e.target.files[0] }))}
          className="file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-accent hover:file:bg-blue-100"
        />
      );
    }


    if (propSchema.enum) {
      return (
        <select value={value} onChange={handleChange} className={commonClasses}>
          <option value="" disabled>Select...</option>
          {propSchema.enum.map(opt => <option key={opt} value={opt}>{opt}</option>)}
        </select>
      );
    }


    if (propSchema.type === 'array' || propSchema.description?.includes('newline-separated')) {
      const displayValue = Array.isArray(value) ? value.join('\n') : value;
      return (
        <textarea 
          rows="4" 
          value={displayValue} 
          onChange={handleChange} 
          placeholder={propSchema.description} 
          className={commonClasses}
        />
      );
    }


    if (propSchema.type === 'boolean') {
      return (
        <input 
          type="checkbox" 
          checked={!!value} 
          onChange={(e) => setFormData(p => ({ ...p, [key]: e.target.checked }))}
          className="w-5 h-5"
        />
      );
    }


    return (
      <input 
        type={propSchema.type === 'integer' ? 'number' : 'text'} 
        value={value} 
        onChange={handleChange} 
        placeholder={propSchema.description} 
        className={commonClasses}
      />
    );
  };


  const renderParameterInput = (param) => {
    const commonClasses = "w-full p-2.5 border border-slate-300 rounded-md box-border font-inter focus:ring-2 focus:ring-accent focus:border-accent outline-none";
    const value = formData[param.name] || '';


    const handleChange = (e) => {
      setFormData(p => ({ ...p, [param.name]: e.target.value }));
    };


    if (param.schema?.enum) {
      return (
        <select value={value} onChange={handleChange} className={commonClasses}>
          <option value="">Select...</option>
          {param.schema.enum.map(opt => <option key={opt} value={opt}>{opt}</option>)}
        </select>
      );
    }


    return (
      <input 
        type={param.schema?.type === 'integer' ? 'number' : 'text'} 
        value={value} 
        onChange={handleChange} 
        placeholder={param.description} 
        className={commonClasses}
        required={param.required}
      />
    );
  };


  const totalPages = Math.ceil(pagination.total / perPage);


  const renderPagination = () => {
    if (isHistoryLoading || pagination.total <= perPage) return null;
    return (
      <div className="flex justify-end items-center gap-2 p-4 border-t border-slate-200">
        <span className="text-xs text-slate-500">
          Page {pagination.page} of {totalPages}
        </span>
        <button
          onClick={() => setCurrentPage(p => p - 1)}
          disabled={pagination.page <= 1}
          className="p-1.5 border bg-white border-slate-300 rounded-md text-slate-700 hover:bg-slate-50 disabled:opacity-50"
        >
          <ChevronLeft size={16} />
        </button>
        <button
          onClick={() => setCurrentPage(p => p + 1)}
          disabled={pagination.page >= totalPages}
          className="p-1.5 border bg-white border-slate-300 rounded-md text-slate-700 hover:bg-slate-50 disabled:opacity-50"
        >
          <ChevronRight size={16} />
        </button>
      </div>
    );
  };


  const responseSchema = endpoint.responses['200']?.content?.['application/json']?.schema;
  const isTableData = localResponse?.type === 'success' && Array.isArray(localResponse?.data) && responseSchema?.type === 'array';
  const responseData = localResponse?.data;


  const hasResultsComponents = useMemo(() => {
    return customUi.some(comp => comp.layout?.zone === 'results');
  }, [customUi]);


  const allInputFields = useMemo(() => {
    const fields = [...schemaProperties];
    
    if (endpoint.parameters) {
      const customFieldNames = customUi.filter(comp => comp.props?.name).map(comp => comp.props.name);
      endpoint.parameters.forEach(param => {
        if (!customFieldNames.includes(param.name)) {
          fields.push({ key: param.name, param });
        }
      });
    }
    
    return fields;
  }, [schemaProperties, endpoint.parameters, customUi]);


  return (
    <>
      <div className="bg-white border border-slate-200 rounded-lg p-8">
        <h2 className="text-2xl font-semibold mt-0">{endpoint.summary}</h2>
        <p className="mt-0 text-slate-500">{endpoint.description}</p>


        <ZoneRenderer
          zone="header"
          components={customUi}
          formData={formData}
          setFormData={setFormData}
          isLoading={isLoading}
          className="mb-4"
        />


        <div className="my-6">
          <ZoneRenderer
            zone="body"
            components={customUi.filter(comp => comp.name !== 'ConfirmDialog')}
            formData={formData}
            setFormData={setFormData}
            onExecute={handleRun}
            isLoading={isLoading}
          />


          {allInputFields.length > 0 && (
            <div className="grid grid-cols-[150px_1fr] gap-x-5 gap-y-5 items-center mt-4">
              {allInputFields.map(({ key, propSchema, param }) => (
                <React.Fragment key={key}>
                  <label className="font-medium text-right text-slate-700 capitalize">
                    {param ? param.name : key.replace(/([A-Z])/g, ' $1')}
                    {(param?.required || propSchema?.required) && <span className="text-rose-500 ml-1">*</span>}
                  </label>
                  {param ? renderParameterInput(param) : renderSchemaInput(key, propSchema)}
                </React.Fragment>
              ))}
            </div>
          )}


          {!hasCustomBodyComponents && allInputFields.length === 0 && (
            <p className="my-8 text-slate-500">No parameters required for this action.</p>
          )}
        </div>


        {runningTasks.length > 0 && showConcurrencyWarning && (
          <div className="mt-4 p-3 bg-blue-50 border border-blue-200 text-blue-800 rounded-md flex items-start gap-3 text-sm relative">
            <AlertTriangle size={18} className="flex-shrink-0 mt-0.5" />
            <div>
              <span className="font-semibold">
                {runningTasks.length} task{runningTasks.length > 1 ? 's are' : ' is'} currently in progress.
              </span>
              <p className="text-xs mt-1">Check the execution history below for real-time status updates.</p>
            </div>
            <button
             onClick={() => setShowConcurrencyWarning(false)}
             className="absolute top-2 right-2 p-1 rounded-full hover:bg-blue-100"
             title="Dismiss"
            >
              <X size={16} />
            </button>
          </div>
        )}


        <div className="flex justify-end mt-4">
          <button
            className="bg-accent hover:bg-accent-dark text-white font-medium py-2 px-6 rounded-md inline-flex items-center justify-center min-w-[120px] disabled:bg-slate-300 disabled:cursor-not-allowed"
            onClick={handleExecuteClick}
            disabled={isLoading}
          >
            {isLoading ? (
              <div className="w-5 h-5 border-2 border-white border-b-transparent rounded-full animate-spin" />
            ) : (
              'Execute'
            )}
          </button>
        </div>


        {localResponse && (
          <div className="mt-6">
            <div className="flex justify-between items-center mb-2">
              <h4 className="text-lg font-semibold">Latest Response</h4>
              {!hasResultsComponents && typeof localResponse.data === 'object' && localResponse.data !== null && (
                <JsonViewToggle viewMode={jsonViewMode} onViewChange={setJsonViewMode} />
              )}
            </div>


            {hasResultsComponents && (
              <ZoneRenderer
                zone="results"
                components={customUi}
                responseData={responseData}
                isLoading={isLoading}
                className="mb-4"
              />
            )}


            {!hasResultsComponents && (
              <>
                {isTableData ? (
                  <ResultsTable data={localResponse.data} schema={responseSchema} />
                ) : jsonViewMode === 'hierarchical' ? (
                  <JsonHierarchicalView data={localResponse.data} />
                ) : (
                  <pre className={`font-fira text-xs bg-slate-100 p-4 rounded-md whitespace-pre-wrap break-all max-h-[400px] overflow-y-auto border-l-4 ${localResponse.type === 'success' ? 'border-green-500' : 'border-red-500'}`}>
                    {JSON.stringify(localResponse.data, null, 2)}
                  </pre>
                )}
              </>
            )}
          </div>
        )}
      </div>


      {confirmDialogConfig && (
        <ConfirmDialog
          open={showConfirmDialog}
          title={confirmDialogConfig.props.title}
          message={confirmDialogConfig.props.message}
          confirmText={confirmDialogConfig.props.confirmText}
          cancelText={confirmDialogConfig.props.cancelText}
          danger={confirmDialogConfig.props.danger}
          onConfirm={handleConfirmExecute}
          onCancel={handleCancelExecute}
        />
      )}


      <div className="mt-8">
        <div className="bg-white border border-slate-200 rounded-lg">
          <div className="p-4 font-medium flex justify-between items-center">
            <span>Execution History ({pagination.total})</span>
            {localHistory.length > 0 && (
              <JsonViewToggle viewMode={jsonViewMode} onViewChange={setJsonViewMode} />
            )}
          </div>
          <div className="p-4 border-t border-slate-200">
            {isHistoryLoading && localHistory.length === 0 ? (
              <p className="text-text-secondary text-sm">Loading history...</p>
            ) : localHistory.length > 0 ? (
              <div className="space-y-3">
                {localHistory.map((req) => (
                  <HistoryItem key={req.id || req.task_id} request={req} jsonViewMode={jsonViewMode} />
                ))}
              </div>
            ) : (
              <p className="text-text-secondary text-sm">No requests have been made for this endpoint yet.</p>
            )}
          </div>
          {renderPagination()}
        </div>
      </div>
    </>
  );
};


export default EndpointRenderer;


// src/pages/RequestHistoryPage.js
 
import React, { useContext, useEffect, useState, useMemo } from 'react';
import { RequestContext } from '../context/RequestContext';
import { HistoryItem } from '../components/ui/HistoryItem';
import JsonViewToggle from '../components/ui/JsonViewToggle';
import { ChevronLeft, ChevronRight } from 'lucide-react';
import { PreferenceContext } from '../context/PreferenceContext';
 
const RequestHistoryPage = () => {
  // Get pagination info from the RequestContext
  const { history, pagination, isLoading, error, fetchHistory } = useContext(RequestContext);
  // Get JSON view preference from the PreferenceContext
  const { preferences, setJsonViewMode } = useContext(PreferenceContext);
  const { jsonViewMode } = preferences;
   
  // State for filters and pagination remains local to this page
  const [filters, setFilters] = useState({ application: '', status: '' });
  const [currentPage, setCurrentPage] = useState(1);
  const perPage = 10;
 
  useEffect(() => {
    // Fetch history whenever filters or the current page change
    fetchHistory(filters, currentPage, perPage);
  }, [filters, currentPage, fetchHistory]);
 
  const handleFilterChange = (e) => {
    const { name, value } = e.target;
    setFilters(prev => ({ ...prev, [name]: value }));
    // When filters change, always go back to the first page
    setCurrentPage(1);
  };
 
  // Memoize pagination calculations from the context state
  const { total, page: apiPage } = pagination;
  const totalPages = useMemo(() => Math.ceil(total / perPage), [total, perPage]);
 
  const renderContent = () => {
    if (isLoading && history.length === 0) { // Show full-page loader only on initial load
      return (
        <div className="flex justify-center items-center py-10">
          <div className="w-8 h-8 border-4 border-slate-200 border-t-accent rounded-full animate-spin" />
        </div>
      );
    }
    if (error) {
      return <div className="text-center py-10 text-red-500 font-medium">{error}</div>;
    }
    if (history.length === 0) {
      return (
        <div className="text-center py-10 border-2 border-dashed border-slate-200 rounded-lg bg-white">
          <p className="text-text-secondary">No requests found matching your criteria.</p>
          <p className="text-sm text-slate-400 mt-2">Execute an action from a service page to see its history here.</p>
        </div>
      );
    }
     
    return history.map((req, index) => (
      <HistoryItem 
        key={req.id || req.task_id || index} 
        request={req} 
        jsonViewMode={jsonViewMode}
        displayTitle={`${req.application}: ${req.target_url}`}
      />
    ));
  };
   
  const renderPagination = () => {
    if (isLoading || total <= perPage) return null;
 
    return (
      <div className="flex justify-between items-center mt-6">
        <span className="text-sm text-slate-600">
          Showing <span className="font-medium">{((apiPage - 1) * perPage) + 1}</span>-
          <span className="font-medium">{Math.min(apiPage * perPage, total)}</span> of 
          <span className="font-medium"> {total}</span> results
        </span>
        <div className="flex items-center gap-2">
          <button
            onClick={() => setCurrentPage(p => p - 1)}
            disabled={apiPage <= 1}
            className="px-2.5 py-1.5 flex items-center gap-1.5 border bg-white border-slate-300 rounded-md text-sm font-medium text-slate-700 hover:bg-slate-50 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
          >
            <ChevronLeft size={16} />
            Previous
          </button>
          <span className="text-sm text-slate-500 font-medium tabular-nums">
            Page {apiPage} of {totalPages}
          </span>
          <button
            onClick={() => setCurrentPage(p => p + 1)}
            disabled={apiPage >= totalPages}
            className="px-2.5 py-1.5 flex items-center gap-1.5 border bg-white border-slate-300 rounded-md text-sm font-medium text-slate-700 hover:bg-slate-50 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
          >
            Next
            <ChevronRight size={16} />
          </button>
        </div>
      </div>
    );
  };
 
  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-2xl font-bold text-text-primary m-0">Request History</h1>
         
        <div className="flex items-center gap-2">
          <input
            type="text"
            name="application"
            value={filters.application}
            onChange={handleFilterChange}
            placeholder="Filter by Application..."
            className="px-2 py-1.5 border bg-white border-slate-300 rounded-md focus:ring-2 focus:ring-accent focus:border-accent outline-none text-sm"
          />
          <select
            name="status"
            value={filters.status}
            onChange={handleFilterChange}
            className="px-2 py-1.5 border bg-white border-slate-300 rounded-md focus:ring-2 focus:ring-accent focus:border-accent outline-none text-sm"
          >
            <option value="">All Statuses</option>
            <option value="SUCCESS">Success</option>
            <option value="ERROR">Error</option>
            <option value="PENDING">Pending</option>
            <option value="RUNNING">Running</option>
            <option value="TIMEOUT">Timeout</option>
          </select>
 
          {history.length > 0 && (
            <JsonViewToggle viewMode={jsonViewMode} onViewChange={setJsonViewMode} />
          )}
        </div>
      </div>
 
      <div className="relative min-h-[100px]">
        {isLoading && <div className="absolute inset-0 bg-white/50 z-10 transition-opacity" />}
        <div className="space-y-3">
          {renderContent()}
        </div>
      </div>
 
      {renderPagination()}
    </div>
  );
};
 
export default RequestHistoryPage;



// src/pages/DashboardPage.js
 
import React, { useMemo, useContext } from 'react';
import { useParams } from 'react-router-dom';
import ServiceCard from '../components/ServiceCard';
import ServiceListItem from '../components/ServiceListItem';
import { Search, LayoutGrid, List } from 'lucide-react';
import { useSessionStorage } from '../hooks/useStorage'; // Import the new hook
import { PreferenceContext } from '../context/PreferenceContext'; // Import the preference context
 
const DashboardPage = ({ allServices, favorites, onFavoriteToggle }) => {
  const { filter, categoryName } = useParams();
 
  // --- UPDATED: Use context for persistent view mode ---
  const { preferences, setViewMode } = useContext(PreferenceContext);
  const { viewMode } = preferences;
 
  // --- UPDATED: Use session storage for the search term ---
  const [searchTerm, setSearchTerm] = useSessionStorage('dashboard-search-term', '');
 
  const pageTitle = useMemo(() => {
    if (filter === 'favorites') return 'All Favourites';
    if (categoryName) return categoryName;
    return 'All Services';
  }, [filter, categoryName]);
 
  // ... (displayedServices and servicesByCategory memos are unchanged) ...
  const displayedServices = useMemo(() => {
    let services = allServices;
 
    if (filter === 'favorites') {
      services = services.filter(s => favorites.includes(s.id));
    }
 
    if (categoryName) {
      services = services.filter(s => s.category === categoryName);
    }
 
    if (searchTerm) {
      const lowercasedTerm = searchTerm.toLowerCase();
      services = services.filter(s =>
        s.title.toLowerCase().includes(lowercasedTerm) ||
        s.description.toLowerCase().includes(lowercasedTerm) ||
        (s.category && s.category.toLowerCase().includes(lowercasedTerm)) ||
        (s.tags && s.tags.some(tag => tag.toLowerCase().includes(lowercasedTerm)))
      );
    }
    return services;
  }, [filter, searchTerm, favorites, allServices, categoryName]);
 
  const servicesByCategory = useMemo(() => {
    if (categoryName) {
      return { [categoryName]: displayedServices };
    }
    return displayedServices.reduce((acc, service) => {
      const category = service.category || 'Other';
      if (!acc[category]) {
        acc[category] = [];
      }
      acc[category].push(service);
      return acc;
    }, {});
  }, [displayedServices, categoryName]);
 
  const categories = Object.keys(servicesByCategory).sort();
 
  const ViewToggle = () => (
    <div className="flex items-center p-1 bg-slate-100 border border-slate-200 rounded-lg">
      <button
        onClick={() => setViewMode('grid')}
        className={`p-1 flex items-center gap-1.5 rounded-md text-sm transition-colors ${viewMode === 'grid' ? 'bg-white shadow-sm text-accent font-semibold' : 'text-slate-500 hover:text-slate-800'
          }`}
        title="Grid View"
      >
        <LayoutGrid size={16} />
      </button>
      <button
        onClick={() => setViewMode('list')}
        className={`p-1 flex items-center gap-1.5 rounded-md text-sm transition-colors ${viewMode === 'list' ? 'bg-white shadow-sm text-accent font-semibold' : 'text-slate-500 hover:text-slate-800'
          }`}
        title="List View"
      >
        <List size={16} />
      </button>
    </div>
  );
 
  return (
    <div>
      {/* ... (header section is unchanged) ... */}
      <div className="flex justify-between items-center mb-5">
        <div className="flex items-center gap-4">
          <h1 className="text-2xl font-bold text-text-primary m-0">{pageTitle}</h1>
        </div>
        <div className='flex gap-2'>
          <div className="relative w-96">
            <input
              type="text"
              placeholder="Search by name, tag, category..."
              className="w-full pl-4 pr-9 py-2 bg-white border border-slate-300 rounded-lg text-sm focus:border-accent focus:ring-1 focus:ring-accent outline-none transition"
              value={searchTerm}
              onChange={e => setSearchTerm(e.target.value)}
            />
            <Search size={16} className="absolute right-3 top-1/2 -translate-y-1/2 text-slate-400" />
          </div>
          <ViewToggle />
        </div>
      </div>
 
      <div className="space-y-8">
        {categories.length > 0 && displayedServices.length > 0 ? (
          categories.map(category => (
            <div key={category}>
              {!categoryName && (
                <h2 className="text-lg font-semibold mb-3 text-text-primary border-b border-slate-200 pb-2">{category}</h2>
              )}
              {viewMode === 'grid' ? (
                <div className="grid grid-cols-[repeat(auto-fill,minmax(300px,1fr))] gap-4">
                  {servicesByCategory[category].map(service => (
                    <ServiceCard
                      key={service.id}
                      service={service}
                      isFavorite={favorites.includes(service.id)}
                      onFavoriteToggle={onFavoriteToggle}
                    />
                  ))}
                </div>
              ) : (
                <div className="space-y-2">
                  {servicesByCategory[category].map(service => (
                    <ServiceListItem
                      key={service.id}
                      service={service}
                      isFavorite={favorites.includes(service.id)}
                      onFavoriteToggle={onFavoriteToggle}
                    />
                  ))}
                </div>
              )}
            </div>
          ))
        ) : (
          <div className="col-span-full text-center py-10 border-2 border-dashed border-slate-200 rounded-lg bg-white">
            <p className="text-text-secondary">
              {filter === 'favorites' && !searchTerm && !categoryName
                ? 'You have not favorited any services yet.'
                : 'No services match your criteria.'
              }
            </p>
          </div>
        )}
      </div>
    </div>
  );
};
 
export default DashboardPage;


import React, { useState, useEffect, useMemo, useContext, useCallback } from 'react';
import { useParams, Navigate } from 'react-router-dom';
import EndpointRenderer from '../components/ui/EndpointRenderer';
import apiService from '../api/apiService';
import { RequestContext } from '../context/RequestContext';
import { PreferenceContext } from '../context/PreferenceContext';
import { HistoryItem } from '../components/ui/HistoryItem';
import { Maximize, Minimize, ChevronLeft, ChevronRight, AlertTriangle } from 'lucide-react';
import JsonViewToggle from '../components/ui/JsonViewToggle';
import { validateSpec, sanitizeSpec } from '../utils/specValidator';
 

const ServiceHistoryViewer = ({ service, contextHistory }) => {
  const [localHistory, setLocalHistory] = useState([]);
  const [pagination, setPagination] = useState({ page: 1, per_page: 5, total: 0 });
  const [currentPage, setCurrentPage] = useState(1);
  const [isLoading, setIsLoading] = useState(true);
  const perPage = 5;


  const { preferences, setJsonViewMode } = useContext(PreferenceContext);
  const { jsonViewMode } = preferences;


  const fetchServiceHistory = useCallback(async (page) => {
    setIsLoading(true);
    try {
      const filters = { application: service.id };
      const response = await apiService.getHistory({ ...filters, page, per_page: perPage });
      setLocalHistory(response.data.results || []);
      setPagination({
        page: response.data.page,
        per_page: response.data.per_page,
        total: response.data.total
      });
    } catch (error) {
      console.error(`Failed to fetch history for ${service.id}:`, error);
      setLocalHistory([]);
    } finally {
      setIsLoading(false);
    }
  }, [service.id]);


  useEffect(() => {
    fetchServiceHistory(currentPage);
  }, [currentPage, fetchServiceHistory]);


  useEffect(() => {
    if (!contextHistory || contextHistory.length === 0) return;
    
    setLocalHistory(prevLocal => {
      const updatedItems = new Map(contextHistory.map(item => [item.task_id, item]));
      return prevLocal.map(localItem => updatedItems.get(localItem.task_id) || localItem);
    });
  }, [contextHistory]);
  
  const totalPages = Math.ceil(pagination.total / perPage);


  const renderPagination = () => {
    if (isLoading || pagination.total <= perPage) return null;
    return (
      <div className="flex justify-end items-center gap-2 p-3 border-t border-slate-200">
        <span className="text-xs text-slate-500">
          Page {pagination.page} of {totalPages}
        </span>
        <button
          onClick={() => setCurrentPage(p => p - 1)}
          disabled={pagination.page <= 1}
          className="p-1.5 border bg-white border-slate-300 rounded-md text-slate-700 hover:bg-slate-50 disabled:opacity-50"
        >
          <ChevronLeft size={16} />
        </button>
        <button
          onClick={() => setCurrentPage(p => p + 1)}
          disabled={pagination.page >= totalPages}
          className="p-1.5 border bg-white border-slate-300 rounded-md text-slate-700 hover:bg-slate-50 disabled:opacity-50"
        >
          <ChevronRight size={16} />
        </button>
      </div>
    );
  };


  return (
    <div className="mt-10">
      <div className="bg-white border border-slate-200 rounded-lg">
        <div className="p-3 text-lg font-semibold flex justify-between items-center">
          <span>History for {service.title} ({pagination.total})</span>
          {localHistory.length > 0 && <JsonViewToggle viewMode={jsonViewMode} onViewChange={setJsonViewMode} />}
        </div>
        <div className="p-3 border-t border-slate-200">
          {isLoading && localHistory.length === 0 ? (
            <p className="text-text-secondary text-sm">Loading history...</p>
          ) : localHistory.length > 0 ? (
            <div className="space-y-3">
              {localHistory.map(req => (<HistoryItem key={req.id || req.task_id} request={req} jsonViewMode={jsonViewMode} />))}
            </div>
          ) : (
            <p className="text-text-secondary text-sm">No requests have been made for this service yet.</p>
          )}
        </div>
        {renderPagination()}
      </div>
    </div>
  );
};


const ServiceUIPage = ({ allServices }) => {
  const { serviceId } = useParams();
  const { history: contextHistory } = useContext(RequestContext);
  const service = useMemo(() => allServices.find(s => s.id === serviceId), [allServices, serviceId]);


  const [spec, setSpec] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [activeOperationId, setActiveOperationId] = useState(null);
  const [validationResults, setValidationResults] = useState(null);
  
  const [isIframeFullscreen, setIsIframeFullscreen] = useState(false);
  const [iframeSrcUrl, setIframeSrcUrl] = useState(null);
  const [iframeUrlLoading, setIframeUrlLoading] = useState(false);
  const [iframeError, setIframeError] = useState(null);


  useEffect(() => {
    setActiveOperationId(null);
    setSpec(null);
    setError(null);
    setValidationResults(null);
    setIsIframeFullscreen(false);
    setIframeSrcUrl(null);
    setIframeError(null);
    
    if (!service) {
      setLoading(false);
      return;
    }


    const fetchIframeUrl = async () => {
      if (service.ui_type === 'iframe' && service.get_iframe_url) {
        try {
          setIframeUrlLoading(true);
          const response = await apiService.getDynamicUrl(service.get_iframe_url);
          if (response.data && response.data.redirect_url) {
            setIframeSrcUrl(response.data.redirect_url);
          } else {
            throw new Error("The API response did not contain a 'redirect_url'.");
          }
        } catch (err) {
          console.error("Failed to fetch iframe URL:", err);
          setIframeError(`Could not load the application. Failed to retrieve the secure URL.`);
        } finally {
          setIframeUrlLoading(false);
        }
      }
    };


    const fetchSpec = async () => {
      if (!service.metadata_url) {
        setLoading(false);
        return;
      }
      try {
        setLoading(true);
        const response = await apiService.getSpec(service.metadata_url);
        const openApiSpec = response.data;


        // Validate spec
        const validation = validateSpec(openApiSpec);
        setValidationResults(validation);


        // Log validation results
        if (validation.errors.length > 0) {
          console.group('âŒ OpenAPI Spec Validation Errors');
          validation.errors.forEach(err => console.error(err));
          console.groupEnd();
        }
        if (validation.warnings.length > 0) {
          console.group('âš ï¸ OpenAPI Spec Validation Warnings');
          validation.warnings.forEach(warn => console.warn(warn));
          console.groupEnd();
        }


        // Sanitize and continue even if validation fails
        const sanitized = {
          ...openApiSpec,
          'x-custom-ui': {
            ...openApiSpec['x-custom-ui'],
            components: sanitizeSpec(openApiSpec)
          }
        };


        setSpec(sanitized);
      } catch (err) {
        setError(`Failed to load API Specification for ${service.title}.`);
        console.error(err);
      } finally {
        setLoading(false);
      }
    };


    if (service.ui_type === 'iframe') {
      fetchIframeUrl();
      setLoading(false);
    } else {
      fetchSpec();
    }


  }, [service]);


  const availableOperations = useMemo(() => {
    if (!spec || !spec.paths) return [];
    const operations = [];
    for (const path in spec.paths) {
      for (const method in spec.paths[path]) {
        const endpoint = spec.paths[path][method];
        if (endpoint.operationId && endpoint.summary) {
          operations.push({
            operationId: endpoint.operationId,
            title: endpoint.summary,
            description: endpoint.description || `Execute the ${method.toUpperCase()} request on ${path}.`,
            path: path,
            method: method,
            fullEndpoint: endpoint
          });
        }
      }
    }
    return operations;
  }, [spec]);
  
  const activeEndpoint = useMemo(() => {
    if (!activeOperationId) return null;
    const op = availableOperations.find(o => o.operationId === activeOperationId);
    return op ? { ...op.fullEndpoint, path: op.path, method: op.method } : null;
  }, [activeOperationId, availableOperations]);


  const customUiForOperation = useMemo(() => {
    if (!spec || !spec['x-custom-ui'] || !spec['x-custom-ui'].components) return [];
    const comps = spec['x-custom-ui'].components;
    return comps.filter(c => {
      if (c.target === 'service') return true;
      if (activeOperationId && c.target === `operationId:${activeOperationId}`) return true;
      if (activeEndpoint && c.target === activeEndpoint.path) return true;
      return false;
    });
  }, [spec, activeOperationId, activeEndpoint]);


  const showValidationBanner = useMemo(() => {
    return validationResults && (
      validationResults.errors.length > 0 || 
      validationResults.warnings.length > 0
    );
  }, [validationResults]);


  if (!service && !loading) {
    return <Navigate to="/services/all" replace />;
  }


  if (loading) {
    return (
      <div className="flex items-center gap-2 p-8">
        <div className="w-5 h-5 border-2 border-slate-600 border-b-transparent rounded-full animate-spin" />
        <span>Loading service details...</span>
      </div>
    );
  }


  if (error) {
    return (
      <div className="p-8">
        <div className="bg-red-50 border border-red-200 rounded-lg p-4">
          <div className="flex items-start gap-2">
            <AlertTriangle className="text-red-600 flex-shrink-0" size={20} />
            <div>
              <div className="font-medium text-red-900">Error Loading Service</div>
              <div className="text-sm text-red-700 mt-1">{error}</div>
            </div>
          </div>
        </div>
      </div>
    );
  }
  
  const renderServiceContent = () => {
    if (service.ui_type === 'iframe') {
      const renderIframeContent = () => {
        if (iframeUrlLoading) {
          return (
            <div className="flex items-center justify-center h-full gap-2 text-slate-500">
              <div className="w-5 h-5 border-2 border-slate-600 border-b-transparent rounded-full animate-spin" />
              <span>Loading Application...</span>
            </div>
          );
        }
        if (iframeError) {
          return <div className="flex items-center justify-center h-full text-red-600 p-4 text-center">{iframeError}</div>;
        }
        if (iframeSrcUrl) {
          return (
            <>
              <iframe
                src={iframeSrcUrl}
                title={service.title}
                className="w-full h-full border-0"
                style={{ borderRadius: isIframeFullscreen ? '0' : '0.5rem' }}
              />
              {isIframeFullscreen && (
                <button
                  onClick={() => setIsIframeFullscreen(false)}
                  className="absolute top-4 right-4 flex items-center gap-2 px-3 py-2 text-sm font-medium text-white bg-black/60 rounded-md hover:bg-black/80 transition-colors backdrop-blur-sm"
                  title="Exit Fullscreen"
                >
                  <Minimize size={16} />
                  <span>Exit Fullscreen</span>
                </button>
              )}
            </>
          );
        }
        return null;
      };


      return (
        <>
          <div className="flex justify-between items-start mb-4">
            <div>
              <h1 className="text-2xl font-bold">{service.title}</h1>
              <p className="text-slate-500 mt-1">{service.description}</p>
            </div>
            <button
              onClick={() => setIsIframeFullscreen(!isIframeFullscreen)}
              className="flex items-center gap-1.5 px-2.5 py-1.5 text-sm font-medium text-slate-600 bg-white border border-slate-300 rounded-md hover:bg-slate-50 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
              title={isIframeFullscreen ? "Exit Fullscreen" : "Enter Fullscreen"}
              disabled={!iframeSrcUrl}
            >
              {isIframeFullscreen ? <Minimize size={16} /> : <Maximize size={16} />}
              <span>{isIframeFullscreen ? "Exit" : "Fullscreen"}</span>
            </button>
          </div>
          <div className={`
            bg-white border border-slate-200 shadow-sm transition-all duration-300
            ${isIframeFullscreen
              ? 'fixed inset-0 z-50 w-screen h-screen rounded-none border-none'
              : 'relative w-full h-[calc(100vh-230px)] rounded-lg'
            }
          `}>
            {renderIframeContent()}
          </div>
        </>
      );
    }


    if (spec) {
      return (
        <>
          {showValidationBanner && (
            <div className="mb-4 bg-amber-50 border border-amber-200 rounded-lg p-3">
              <div className="flex items-start gap-2">
                <AlertTriangle className="text-amber-600 flex-shrink-0 mt-0.5" size={18} />
                <div className="flex-1">
                  <div className="font-medium text-amber-900 text-sm">
                    OpenAPI Spec Issues Detected
                  </div>
                  <div className="text-xs text-amber-700 mt-1 space-y-0.5">
                    {validationResults.errors.length > 0 && (
                      <div>
                        <strong>{validationResults.errors.length} Error(s):</strong> Some components may not render
                      </div>
                    )}
                    {validationResults.warnings.length > 0 && (
                      <div>
                        <strong>{validationResults.warnings.length} Warning(s):</strong> Components may not work as expected
                      </div>
                    )}
                  </div>
                  <button
                    onClick={() => {
                      console.group('ðŸ“‹ OpenAPI Spec Validation Results');
                      console.error('Errors:', validationResults.errors);
                      console.warn('Warnings:', validationResults.warnings);
                      console.groupEnd();
                    }}
                    className="text-xs text-amber-800 underline mt-1.5"
                  >
                    View Details in Console
                  </button>
                </div>
              </div>
            </div>
          )}


          <h1 className="text-2xl font-bold">{spec?.info?.title || service.title}</h1>
          <p className="text-slate-500 mt-1 mb-6">{spec?.info?.description || service.description}</p>
          
          {!activeEndpoint ? (
            <div className="grid grid-cols-[repeat(auto-fill,minmax(250px,1fr))] gap-4">
              {availableOperations.map(card => (
                <div 
                  key={card.operationId} 
                  className="bg-white border border-slate-200 rounded-lg p-5 cursor-pointer transition-all hover:border-accent hover:shadow-lg hover:-translate-y-1" 
                  onClick={() => setActiveOperationId(card.operationId)}
                >
                  <h3 className="font-semibold text-lg m-0 mb-2">{card.title}</h3>
                  <p className="m-0 text-slate-500 text-sm">{card.description}</p>
                </div>
              ))}
            </div>
          ) : (
            <div>
              <div className="mb-5">
                <button 
                  onClick={() => setActiveOperationId(null)} 
                  className="text-accent cursor-pointer hover:underline text-sm"
                >
                  &larr; Back to {service.title} Operations
                </button>
              </div>
              <EndpointRenderer 
                key={activeOperationId} 
                endpoint={activeEndpoint} 
                serviceId={service.id} 
                customUi={customUiForOperation} 
              />
            </div>
          )}
        </>
      );
    }
    
    return (
      <>
        <h1 className="text-2xl font-bold">{service.title}</h1>
        <p className="text-slate-500 mt-1 mb-6">{service.description}</p>
        <div className="bg-white border border-slate-200 rounded-lg p-8">
          This service does not have a dynamic UI configured.
        </div>
      </>
    );
  };


  const showHistory = !activeEndpoint && service && service.ui_type !== 'iframe';
  
  return (
    <div className={isIframeFullscreen ? 'iframe-fullscreen-active' : ''}>
      {renderServiceContent()}
      
      {showHistory && (
        <ServiceHistoryViewer service={service} contextHistory={contextHistory} />
      )}
    </div>
  );
};


export default ServiceUIPage;



// src/api/apiService.js
import apiClient from "./apiClient";
import { getDynamicUrl } from "./apiClient";
 
const apiService = {
 // --- Core Services ---
 getServices: () => apiClient.get('/core/services'),
 getSpec: (openApiUrl) => apiClient.get(`/core/info/${openApiUrl}`),
 executeOperation: (config) => apiClient({
   ...config,
   url: `/core/execute/${config.serviceId}${config.path}` // Construct full URL
 }),
 getTaskStatus: (taskEndpoint) => apiClient.get(taskEndpoint),
 
 // --- History Services ---
 getHistory: (filters = {}) => apiClient.get('/history/list', { params: filters }),
 getPending: () => apiClient.get('/history/pending'),
 
 // --- Favorites Services ---
 getFavorites: () => apiClient.get('/favorites/list'),
 addFavorite: (application_id) => apiClient.post('/favorites/add', { application_id }),
 removeFavorite: (application_id) => apiClient.post('/favorites/remove', { application_id }),

 //temporary
 getDynamicUrl
};
 
export default apiService;
 

